<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Swipe Coin Flip</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 10; /* Ensure UI is above messages */
    }
    .temporary-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8); /* Start slightly smaller */
      color: white;
      font-size: 4em; /* Large text */
      font-weight: bold;
      text-align: center;
      background: rgba(0, 0, 0, 0.75);
      padding: 20px 40px;
      border-radius: 10px;
      opacity: 0;
      transition: opacity 0.5s ease-out, transform 0.5s ease-out; /* Smooth fade and scale */
      pointer-events: none; /* Don't interfere with interactions */
      z-index: 5; /* Below main UI but above canvas */
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5); /* Add shadow for readability */
    }
    .temporary-message.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1); /* Scale to full size */
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>Streak: <span id="streak">0</span></div>
    <div>Highest Streak: <span id="highestStreak">0</span></div>
    <div>Results: <span id="results"></span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>

  <!-- Temporary Message Elements -->
  <div id="streakFlash" class="temporary-message"></div>
  <div id="streakRecap" class="temporary-message"></div>
  <div id="streakLostMessage" class="temporary-message"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xff5733);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const originalCameraPosition = new THREE.Vector3(0, 3, 5);
    camera.position.copy(originalCameraPosition);
    camera.lookAt(0, 0, 1.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.PointLight(0xf7fafc, 0.7);
    directionalLight.position.set(0.6, 5, -5);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.radius = 5;
    scene.add(directionalLight);

    const lightTarget = new THREE.Object3D();
    lightTarget.position.set(3, -1, 3);
    scene.add(lightTarget);
    directionalLight.target = lightTarget;

    const world = new CANNON.World();
    world.gravity.set(0, -19.62, 0);

    function createGroundTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#ff5733';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(20 * Math.PI / 180);

      ctx.fillStyle = '#000000';
      ctx.font = 'bold 100px "Roboto", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('flip', 0, 0);

      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 5;
      const textMetrics = ctx.measureText('flip');
      const textWidth = textMetrics.width;
      const textHeight = 100;
      ctx.strokeRect(-textWidth / 2 - 10, -textHeight / 2 - 10, textWidth + 20, textHeight + 20);

      ctx.restore();

      const texture = new THREE.CanvasTexture(canvas);
      texture.offset.set(0.5 - 0.005, 0.5 - 0.005);
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      return texture;
    }

    const groundMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(500, 500),
      new THREE.MeshStandardMaterial({ 
        map: createGroundTexture(),
        color: 0xd1d8e0
      })
    );
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    const groundBody = new CANNON.Body({
      mass: 0,
      shape: new CANNON.Plane(),
      material: new CANNON.Material()
    });
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    const cylinderMesh = new THREE.Mesh(
      new THREE.CylinderGeometry(2, 2, 0.5, 64),
      new THREE.MeshStandardMaterial({
        color: '#ff5733',
        metalness: 0.0,
        roughness: 0.5
      })
    );
    cylinderMesh.position.set(0, -0.2, 0);
    cylinderMesh.castShadow = true;
    cylinderMesh.receiveShadow = true;
    scene.add(cylinderMesh);

    const cylinderShape = new CANNON.Cylinder(2, 2, 0.5, 64);
    const cylinderBody = new CANNON.Body({
      mass: 0,
      shape: cylinderShape,
      material: new CANNON.Material()
    });
    cylinderBody.position.set(0, -0.2, 0);
    const quat = new CANNON.Quaternion();
    quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    cylinderShape.transformAllPoints(new CANNON.Vec3(), quat);
    world.addBody(cylinderBody);

    let streak = 0;
    let highestStreak = 0;
    let streakMaterials = [];
    let grimaceMaterials = [];
    let previousStreak = 0; // Keep track of the previous streak
    let messageTimeout = null; // To manage message display timing

    // Emoji sequence for increasing streak drama
    const emojiSequence = ['😊', '😄', '😎', '😮', '😲', '🤯'];
    const grimaceEmoji = '😬';

    function createTextTexture(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#2d3748';
      ctx.font = '800px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const colorTexture = new THREE.CanvasTexture(canvas);

      const bumpCanvas = canvas.cloneNode();
      const bumpCtx = bumpCanvas.getContext('2d');
      bumpCtx.fillStyle = '#d1e3ff';
      bumpCtx.fillRect(0, 0, 1024, 1024);
      bumpCtx.fillStyle = '#2d3748';
      bumpCtx.font = '800px Arial';
      bumpCtx.textAlign = 'center';
      bumpCtx.textBaseline = 'middle';
      bumpCtx.fillText(text, 512, 512);

      const bumpTexture = new THREE.CanvasTexture(bumpCanvas);
      return { colorTexture, bumpTexture };
    }

    // Get references to message elements
    const streakFlashEl = document.getElementById('streakFlash');
    const streakRecapEl = document.getElementById('streakRecap');
    const streakLostEl = document.getElementById('streakLostMessage');

    // Helper function to show temporary messages
    function showTemporaryMessage(element, text, duration = 1500) {
      // Clear any existing message timeout to prevent overlaps
      if (messageTimeout) {
        clearTimeout(messageTimeout);
        // Immediately hide previous messages if a new one comes quickly
        streakFlashEl.classList.remove('show');
        streakRecapEl.classList.remove('show');
        streakLostEl.classList.remove('show');
      }

      element.textContent = text;
      element.classList.add('show');

      messageTimeout = setTimeout(() => {
        element.classList.remove('show');
        messageTimeout = null; // Clear the timeout reference
      }, duration);
    }

    // Function to create materials based on a text/emoji
    function createMaterialsFromText(text) {
      const textures = createTextTexture(text);
      return [
        new THREE.MeshStandardMaterial({ 
          color: '#FFFFFF', // Edge color
          metalness: 0.0, 
          roughness: 0.15 
        }),
        new THREE.MeshStandardMaterial({ // Heads face (using the provided text)
          map: textures.colorTexture,
          bumpMap: textures.bumpTexture,
          bumpScale: 0.05,
          metalness: 0.0,
          roughness: 0.15
        }),
        new THREE.MeshStandardMaterial({ // Tails face (blank)
          map: createTextTexture(' ').colorTexture, // Keep tails blank
          bumpMap: createTextTexture(' ').bumpTexture,
          bumpScale: -0.05,
          metalness: 0.0,
          roughness: 0.15
        })
      ];
    }

    // Updates the materials used for the settled coin based on streak
    function updateStreakMaterials() {
      // Select emoji based on streak
      // Change emoji every 3 streaks
      const emojiIndex = Math.floor(streak / 3);
      const headsText = emojiSequence[Math.min(emojiIndex, emojiSequence.length - 1)];
      streakMaterials = createMaterialsFromText(headsText);
    }

    // Initialize materials
    grimaceMaterials = createMaterialsFromText(grimaceEmoji);
    updateStreakMaterials(); // Initialize streakMaterials based on initial streak (0)

    const coins = [];
    let results = [];
    let isCoinSettled = true;
    let flipStartTime = 0;

    // Camera shake variables
    let shakeTime = 0;
    const shakeDuration = 0.5; // seconds
    const shakeAmplitude = 1.1; // units

    function createCoin(velocityY = 10, velocityZ = 2, velocityX = 0, spin = 50) {
      try {
        // Clear all existing coins
        coins.forEach(({ mesh, body }) => {
          scene.remove(mesh);
          world.remove(body);
        });
        coins.length = 0;

        // No need to update materials here anymore
        // updateCoinMaterials(); // REMOVED

        const mesh = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32),
          grimaceMaterials // Use grimace materials initially
        );
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);

        const shape = new CANNON.Cylinder(0.5, 0.5, 0.1, 32);
        const quat = new CANNON.Quaternion();
        quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
        shape.transformAllPoints(new CANNON.Vec3(), quat);

        const body = new CANNON.Body({
          mass: 10,
          shape: shape,
          material: new CANNON.Material()
        });
        body.position.set(0, 1, 4);
        body.velocity.set(velocityX, velocityY, velocityZ);
        body.angularVelocity.set(
          Math.min(Math.random() * spin, -25),
          (Math.random() - 0.5) * spin * 0.1,
          (Math.random() - 0.5) * spin * 0.1
        );
        world.addBody(body);

        const coinGroundContact = new CANNON.ContactMaterial(
          groundBody.material,
          body.material,
          { friction: 0.5, restitution: 0.3 }
        );
        const coinCylinderContact = new CANNON.ContactMaterial(
          cylinderBody.material,
          body.material,
          { friction: 0.5, restitution: 0.3 }
        );
        world.addContactMaterial(coinGroundContact);
        world.addContactMaterial(coinCylinderContact);

        coins.push({ mesh, body });
        isCoinSettled = false;
        flipStartTime = performance.now();
        console.log('Coin created');
      } catch (error) {
        console.error('Error creating coin:', error);
      }
    }

    function checkCoinResult() {
      if (coins.length === 0 || isCoinSettled) return;

      const coin = coins[coins.length - 1]; // Check newest coin
      const velocity = coin.body.velocity;
      const angularVelocity = coin.body.angularVelocity;
      let previousStreak = streak; // Store current streak before potentially changing it

      // Check if coin has settled
      if (
        Math.abs(velocity.x) < 0.1 &&
        Math.abs(velocity.y) < 0.1 &&
        Math.abs(velocity.z) < 0.1 &&
        Math.abs(angularVelocity.x) < 0.1 &&
        Math.abs(angularVelocity.y) < 0.1 &&
        Math.abs(angularVelocity.z) < 0.1
      ) {
        try {
          // Get the up vector of the coin in world coordinates
          const up = new THREE.Vector3(0, 1, 0); // Local up for heads
          const worldUp = up.applyQuaternion(coin.mesh.quaternion);

          // Check if coin is heads
          const dot = worldUp.dot(new THREE.Vector3(0, 1, 0));
          const result = dot > 0 ? 'H' : 'T';
          const displayResult = dot > 0 ? '😊' : '❌'; // Use emojis for display

          // Update streak BEFORE updating materials
          if (result === 'H') {
            streak++;
            if (streak > highestStreak) {
              highestStreak = streak;
              document.getElementById('highestStreak').textContent = highestStreak;
            }
            // Check for first time hitting streak of 2
            if (streak === 2 && previousStreak < 2) {
              showTemporaryMessage(streakFlashEl, "Streak of 2!", 2000);
            } else if (streak > 0) { // Show recap for any ongoing streak
              // Make recap message more exciting based on streak length
              let recapMessage = `Streak: ${streak}!`;
              if (streak >= 5) recapMessage = `🔥 Streak: ${streak}!! 🔥`;
              else if (streak >= 3) recapMessage = `✨ Streak: ${streak}! ✨`;
              showTemporaryMessage(streakRecapEl, recapMessage, 1500);
            }
          } else {
            // Check if a streak was active before this flip
            if (streak > 0) {
              showTemporaryMessage(streakLostEl, "Streak Lost!", 2000);
            }
            streak = 0;
          }

          // Update streak materials based on the new streak
          updateStreakMaterials();
          // Apply the updated streak materials to the settled coin
          coin.mesh.material = streakMaterials;

          results.push(displayResult); // Store emoji for results
          if (results.length > 10) results.shift();

          // Update UI
          document.getElementById('streak').textContent = streak;
          document.getElementById('results').textContent = results.join(' ');

          isCoinSettled = true;
          console.log(`Coin settled: ${displayResult}, Streak: ${streak}, Highest Streak: ${highestStreak}`);
        } catch (error) {
          console.error('Error checking coin result:', error);
        }
      }

      // Fallback: Force settlement if coin takes too long
      if (performance.now() - flipStartTime > 10000) {
        isCoinSettled = true;
        results.push('?');
        document.getElementById('results').textContent = results.join(' ');
        console.warn('Coin failed to settle, marked as ?');
      }
    }

    function shakeCamera(deltaTime) {
      if (shakeTime < shakeDuration) {
        shakeTime += deltaTime;
        const intensity = shakeAmplitude * (1 - shakeTime / shakeDuration); // Damped effect
        const offsetX = (Math.random() - 0.5) * intensity;
        const offsetY = (Math.random() - 0.5) * intensity;
        camera.position.set(
          originalCameraPosition.x + offsetX,
          originalCameraPosition.y + offsetY,
          originalCameraPosition.z
        );
        camera.lookAt(0, 0, 1.5);
      } else {
        camera.position.copy(originalCameraPosition);
        camera.lookAt(0, 0, 1.5);
      }
    }

    let touchStartX = null;
    let touchStartY = null;
    let touchStartTime = null;

    window.addEventListener('touchstart', e => {
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchStartTime = performance.now();
    });

    window.addEventListener('touchend', e => {
      if (touchStartY === null || touchStartX === null) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = touchStartY - t.clientY;
      const dt = (performance.now() - touchStartTime) / 1000;

      const velocityY = dy / dt / 100;
      const velocityX = dx / dt / 300;

      if (dy > 30) {
        const spin = Math.min(velocityY * 10, 150);
        createCoin(velocityY * 0.5, velocityY * -0.3, velocityX, spin);
      }

      touchStartX = null;
      touchStartY = null;
      touchStartTime = null;
    });

    let lastTime = performance.now();
    let frameCount = 0;
    let lastFpsUpdateTime = performance.now();
    function animate() {
      try {
        requestAnimationFrame(animate);
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // FPS Calculation
        frameCount++;
        if (currentTime > lastFpsUpdateTime + 1000) {
          const fps = Math.round(frameCount / ((currentTime - lastFpsUpdateTime) / 1000));
          document.getElementById('fps').textContent = `FPS: ${fps}`;
          lastFpsUpdateTime = currentTime;
          frameCount = 0;
        }

        world.step(1 / 120, deltaTime); // Pass deltaTime as second argument

        // Check for ground impact to trigger shake
        coins.forEach(({ body }) => {
          if (body.position.y < 0.1 && Math.abs(body.velocity.y) > 1 && shakeTime === 0) {
            shakeTime = 0; // Start shake
            console.log('Coin hit ground, shaking camera');
          }
        });

        coins.forEach(({ mesh, body }) => {
          mesh.position.copy(body.position);
          mesh.quaternion.copy(body.quaternion);
        });

        checkCoinResult();
        shakeCamera(deltaTime);
        renderer.render(scene, camera);
      } catch (error) {
        console.error('Error in animate loop:', error);
      }
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
